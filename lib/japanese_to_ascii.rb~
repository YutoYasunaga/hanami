# encoding: utf-8

# You can cross-check with some algorhythms available on the net:
#
# https://translate.google.com/m/translate (shows romaji below the Japanese)
# http://nihongo.j-talk.com/ (from the options, choose "Spaced" and "Romaji")
#
# Keep in mind Japanese isn't written with ascii officially, and as such, there
# are no hard rules, especially how to place spaces. This implementation should
# provide should provide something that isn't too hard too read.
#
#
#
#
# Transliterates Japanese. Which is (almost) as hard as translating it.
# Ie, it can be done only approximately without a real life human.
#
# Transliterating Japanese by replacing each character individually is
# impossible. Consider the following Japanese sentences, all containing the
# character 生:
#
#   生まれた子供たち。
#   生きる意味を見失う。
#   生意気な小僧。
#   生える毛は、どうして長いの？
#   生糸がヨーロッパに輸出するようになった。
#   生活に困る。
#   生涯教育のために。
#   芝生のお手入れ。
#
# And now consider (one possible) transliteration:
#
#   umareta kodomo─tachi.
#   ikiru imi o miushinau.
#   namaiki na kozoo.
#   haeru ke wa, dooshite nagai no?
#   kiito ga yooroppa ni yushutsu suruyoo ni natta.
#   seikatsu ni komaru.
#   shoogai kyooiku no tame ni.
#   shibafu no o─teire.
#
# Take a close look. The character 生 (life, to be born, fresh) is 
# transliterated as either "u", "i", "nama", "ha", "ki", "sei", "shou", or "fu"
# depending upon the context. Additionally, note that Japanese hasn't got any
# spaces, but some spaces need to be introduces when transliterating.
#
# However, Japanese does have a syllabary (one glyph for each syllable). These
# are easy to transliterate into ascii on an (almost) 1:1 basis.
#
# Thus, transliteration involves a full-blown morphological analysis, and can
# be divided into three steps.
#
# (a) Parse the Japanese sentence into morphemes (for spaces) and their
#     kana (syllabary) readings (pronunciation). For example, 生まれた子供たち
#     would be turned into "うま,れ,た,こども,たち".
#     There are some free morphological analyzers available, some of them
#     written in/for ruby.
#
# (b) Take the morphemes produced by (a) and merge some of them, especially
#     those that can't occur in isolation. For example, "うま,れ,た" should be
#     merged to "うまれた". To illustrate, it's like writing "it end ed" instead
#     of "it ended". "-ed" is a morpheme, but it should be merged with "end".
#     There are no strict conventions here, so this involves some amount of
#     creativity.
#
# (c) Romanize (=ascii-fy) the kana. This is pretty straigh-forward, and can
#     be done almost with a simple mapping table. There are some combinations
#     of kana that should be transliterated differently, but at any rate, this
#     is the easiest parts and there are several libaries doing this.
#     Note that there are several romanization systems in use, so "こうこう"
#     could be written "koukou", "kookoo", "kōkō", or some rarer variations
#     such as "cȏcȏ".
#
# The code below is an attempt to illustrate how this might be done.


#
# Dictionary files are provided in "./dic" for convenience. It might be hard
# to track down the right version of the dictionaries in UTF-8.
#
#
# Gem <mojinizer> converts kana (Japanese syllabary "alphabet")
# into ascii ("romaji"). Mojinizer uses a rather phonetic approach.
# https://github.com/ikayzo/mojinizer
#
#
# Gem <mecab> needs the mecab binary, see:
# http://mecab.googlecode.com/svn/trunk/mecab/doc/index.html
#
#
#
# TODO
# MERGERS does and probably always will need some fine-tuning.
#

require 'mecab'
require_relative 'mojinizer/mojinizer.rb' # needs gem <moji>

module Japanese
    # load dictionary files dynamically when needed
    TAGGERS = {}

    # dictionary files included
    DICFILE = { :juman => '../dic/juman-utf8',
                :unidic => '../dic/unidic-utf8',
                :ipadic => '../dic/ipadic-utf8'
              }

    # double long vowels or use macrons
    LONG_VOWELS = {
        :double => {'a' => 'aa', 'i' => 'ii', 'u' => 'uu', 'e' => 'ee', 'o' => 'oo'},
        :macron => {'a' => 'ā', 'i' => 'ī', 'u' => 'ū', 'e' => 'ē', 'o' => 'ō'}
    }

    # Replaces punctuation with ASCII.
    PUNCTUATION = {
        '・' => '°', #this can be used in so many ways...
        '※' => '#',
        '　' => ' ', # full width space to half width
        '、' => ',',
        '。' => '.',
        '…' => '...',
        '〃' => '"',
        '〄' => 'JIS',
        '々' => '/-\\',
        '〆' => 'shime',
        '〇' => '0',
        '〈' => '<',
        '〉' => '>',
        '《' => '<<',
        '》' => '>>',
        '「' => '"',
        '」' => '"',
        '『' => "'",
        '』' => "'",
        '【' => '[',
        '】' => ']',
        '〒' => 'T',
        '〓' => '=',
        '〔' => '[',
        '〕' => ']',
        '〖' => '[',
        '〗' => ']',
        '〘' => '[',
        '〙' => ']',
        '〚' => '[',
        '〛' => ']',
        '〜' => '~',
        '〝' => '"',
        '〞' => '"',
        '〟' => '"',
        '〰' => '~~',
        '〱' => '<',
        '〲' => '<"',
        '〳' => '/',
        '〴' => '/"',
        '〵' => '\\',
        '〶' => '(T)'
    }

    MERGERS_UNIDIC = [
        { :type => :suffix, 3 => ','},
        { :type => :suffix, 3 => '・'},
        { :type => :suffix, 4 => ['括弧閉']},
        { :type => :suffix, 4 => ['読点']},
        { :type => :suffix, 4 => ['句点']},
        { :type => :suffix, 4 => ['補助記号', '一般']},
        { :type => :suffix, 0 => 'ん'},
        { :type => :prefix, 4 => ['ダ'], 0 => 'な'},
        { :type => :suffix, 4 => ['助詞'], 3 => 'の', :add => ' '},
        { :type => :suffix, 4 => ['助詞','副助詞'], 3 => 'たり'},
        { :type => :suffix, 4 => ['助詞','副助詞'], 3 => 'だり'},
        { :type => :suffix, 4 => ['デス'], :add => ' '},
        { :type => :suffix, 4 => ['ダ'], :add => ' '},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'て'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'で'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'ながら'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'つつ'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'たって', :add => '─'},
        { :type => :suffix, 4 => ['副助詞','助詞'], 3 => 'って', :add => '─'},
        { :type => :suffix, 4 => ["助動詞"]},

        { :type => :prefix, 3 => '・'},
        { :type => :prefix, 4 => ['括弧開']},
        { :type => :prefix, 4 => ['助動詞','ナイ','仮定形'], 0 => 'なきゃ', :add => ' '},
        { :type => :prefix, 4 => ['助詞','接続助詞'], 0 => 'ちゃ', :add => ' '},
        { :type => :prefix, 4 => ['仮定形']},
        { :type => :prefix, 4 => ['未然形']},
        { :type => :prefix, 4 => ['接頭辞'], :add => '─'},

        [{ 4 => ['連用形']}, { 4 => ['接尾辞','形容詞']}],
        [{ 4 => ['ダ']}, { 4 => ['接続助詞'], 3 => 'けれど'}],
        [{ 4 => ['接続助詞'], 3 => 'て', :add => ' '}, { 4 => ['非自立可能'], 3 => '良い'}],
        [{ 4 => ['接続助詞'], 3 => 'で', :add => ' '}, { 4 => ['非自立可能'], 3 => '良い'}],
        [{ 4 => ['準体助詞'], 3 => 'の'}, { 4 => ['接尾辞','形容詞']}],

        [{ 4 => ['補助記号','一般']}, { 4 => ['補助記号','一般']}],
        [{ 4 => ['格助詞']}, { 4 => ['係助詞']}],
        [{ 4 => ['接続助詞'], 3 => 'て'}, { 4 => ['非自立可能']}],
        [{ 4 => ['接続助詞'], 3 => 'で'}, { 4 => ['非自立可能']}],
        [{ 4 => ['連用形']}, { 4 => ['非自立可能']}],
        [{ 4 => ['連用形']}, { 4 => ['接尾辞','形容詞']}],
        [{ 4 => ['連用形'], :add => '─'}, { 3 => 'そう-様態'}],

        { :type => :suffix, 4 => ['接尾'], :add => '─'},
        { :type => :suffix, 4 => ['接尾辞'], :add => '─'},
    ]


    MERGERS_IPADIC = [
        { :type => :suffix, 4 => ["名詞", "サ変接続", "読仮名なし"]},
        { :type => :suffix, 4 => ['括弧閉']},
        { :type => :suffix, 4 => ['読点']},
        { :type => :suffix, 4 => ['句点']},
        { :type => :suffix, 4 => ['記号', '一般']},
        { :type => :suffix, 0 => 'ん'},
        { :type => :prefix, 4 => ['特殊・ダ','体言接続'], 0 => 'な', :add => ' '},
        { :type => :prefix, 4 => ['係助詞'], 3 => 'は', :add => ' '},
        { :type => :prefix, 4 => ['接続助詞'], 3 => 'ちゃ', :add => ' '},

        { :type => :suffix, 4 => ['名詞','非自立'], 3 => 'もの',  :add => ' '},
        { :type => :suffix, 4 => ['名詞','非自立'], 3 => 'こと', :add => ' '},
        { :type => :suffix, 4 => ['非自立'], 3 => 'の', :add => ' '},
        { :type => :suffix, 4 => ['特殊・デス'], :add => ' '},
        { :type => :suffix, 4 => ['特殊・ダ'], :add => ' '},
        { :type => :suffix, 4 => ['連用タ接続'], 3 => 'がる'},
        { :type => :suffix, 4 => ['接尾'], 3 => 'っぱなし'},
        { :type => :suffix, 4 => ['動詞'], 3 => 'っぱなす'},
        { :type => :suffix, 4 => ['助詞','並立助詞'], 3 => 'たり'},
        { :type => :suffix, 4 => ['助詞','並立助詞'], 3 => 'だり'},
        { :type => :suffix, 4 => ['接尾'], 3 => 'させる'},
        { :type => :suffix, 4 => ['接尾'], 3 => 'せる'},
        { :type => :suffix, 4 => ['接尾'], 3 => 'られる'},
        { :type => :suffix, 4 => ['接尾'], 3 => 'れる'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'て'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'で'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'ながら'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'つつ'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'ちゃ'},

        { :type => :suffix, 4 => ["助動詞"]},

        { :type => :suffix, 4 => ['非自立'], 3 => 'よい', :add => ' '},
        { :type => :suffix, 4 => ['非自立'], 3 => 'いい', :add => ' '},

        { :type => :suffix, 4 => ['非自立']},
        { :type => :suffix, 4 => ['接尾'], :add => '─'},

        { :type => :prefix, 4 => ["名詞", "サ変接続", "読仮名なし"]},
        { :type => :prefix, 4 => ['括弧開']},
        { :type => :prefix, 4 => ['仮定形']},
        { :type => :prefix, 4 => ['未然形']},
        { :type => :prefix, 4 => ['接頭詞'], :add => '─'},

        [{ 4 => ['特殊・ダ']}, { 4 => ['接続助詞'], 3 => 'けど'}],
        [{ 4 => ['記号','一般']}, { 4 => ['記号','一般']}],
        [{ 4 => ['格助詞']}, { 4 => ['係助詞']}],
    ]


    MERGERS_JUMAN = [
        { :type => :prefix, 4 => ['括弧始']},
        { :type => :suffix, 4 => ['括弧終']},

        { :type => :suffix, 4 => ['読点']},
        { :type => :suffix, 4 => ['句点']},
        { :type => :suffix, 4 => ['記号','特殊']},

        { :type => :prefix, 4 => ['仮定形']},
        { :type => :prefix, 4 => ['未然形']},

        { :type => :prefix, 4 => ['ダ列基本連体形'], 0 => 'な'},
        { :type => :suffix, 4 => ['接尾辞'], 3 => 'たい'},
        { :type => :suffix, 4 => ['接尾辞'], 3 => 'がる'},
        { :type => :suffix, 4 => ['動詞'], 3 => 'っぱなす'},
        { :type => :suffix, 4 => ['ナ形容詞'], 3 => 'んだ'},
        { :type => :suffix, 4 => ['助詞','並立助詞'], 3 => 'たり'},
        { :type => :suffix, 4 => ['助詞','並立助詞'], 3 => 'だり'},
        { :type => :suffix, 4 => ['接尾辞'], 3 => 'させる'},
        { :type => :suffix, 4 => ['接尾辞'], 3 => 'せる'},
        { :type => :suffix, 4 => ['接尾辞'], 3 => 'られる'},
        { :type => :suffix, 4 => ['接尾辞'], 3 => 'れる'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'ながら'},
        { :type => :suffix, 4 => ['接続助詞'], 3 => 'つつ'},
        { :type => :suffix, 4 => ["助動詞"], 3 => 'のだ', :add => ' '},
        { :type => :suffix, 4 => ["助動詞"]},
        { :type => :suffix, 4 => ['接尾辞'], 3 => 'ます'},
        { :type => :suffix, 4 => ['非自立']},
        { :type => :suffix, 4 => ['接尾'], :add => '─'},
        { :type => :suffix, 4 => ['接尾辞'], :add => '─'},

        { :type => :prefix, 4 => ['接頭詞'], :add => '─'},

        [{ 4 => ['記号','特殊']}, { 4 => ['記号','特殊']}],
        [{ 4 => ['格助詞']}, { 4 => ['副助詞']}]
    ]

    public

    # aliases
    def self.to_romajiascii(a,b={})
        b[:level] = :romaji
        to_phonetic(a,b)
    end
    def self.to_kana(a,b={})
        b[:level] = :kana
        to_phonetic(a,b)
    end
    
    # strictly convert to ascii, do not leave any other characters
    #   add_unihan_info: replace Unihan characters with some info instead of ?,
    #                    when available (Japanese ON/kun reading, meaning,
    #                    or otherwise Mandarin reading)
    def self.to_ascii(str,opts={})
        opts[:add_unihan_info] ||= true
        # do not allow macrons, and convert to romaji
        opts[:level] = :romaji
        opts[:vowels] = :double
        rom = to_phonetic(str,opts)
        # replace weird kanji with some meaningful info, if possible
        if opts[:add_unihan_info]
            read_unihan if UNIHAN_INFO.empty?
            rom.gsub!(/[\u31c0-\u9fff]/) do |x|
                cp = "U+#{x.codepoints.first.to_s(16).rjust(4,'0')}"
                cp.gsub!(/([a-f])/){$1.upcase}
                if info = UNIHAN_INFO[x.codepoints.first]
                    "{{#{cp}}}: #{info}}}"
                else
                    "{{#{cp}}}}"
                end
            end
        end
        # replace all non-ascii
        rom.gsub(/[^\u0000-\u007f]/,'?')
    end


    # Scans for Japanese text and convert to phonetic representation (kana or romaji).
    # Japanese text = substrings of Katakana + Hiragana +
    #                 Chinese_Characters + Punctuation + Numbers
    # optional options:
    #   dic: :unidic, :ipadic, or :juman, the dictionary to use with the morphological parser
    #   mode: orthographic (ha,wo,he,ou) or :phonetic (wa,o,e,oo)
    #   level: convert to :romaji (shachou) or :kana (シャチョウ)
    #   vowels: :macron (ō) or :double (o), needs mode :phonetic to work properly
    #   system: :hepburn (shachou) or :kunrei (syatyou)
    def self.to_phonetic(str, opts={})
        # defaults
        opts[:mode] ||= :phonetic
        opts[:dic]  ||= :unidic
        opts[:level] ||= :romaji
        opts[:vowels] ||= :double
        opts[:system] ||= :hepburn
        japanese = /([[\u3001-\u30ff]|[\u31c0-\u9fff]|[[:punct:]]|[0-9]|[\uff10-\uff19]]+)/
        lines = str.lines.map do |line|
            line.gsub!(japanese) do |jp|
                kana = kanji_to_kana(jp, opts[:mode], opts[:dic])
                if opts[:level] == :romaji
                    kana_to_ascii(kana, opts[:vowels], opts[:system])
                elsif opts[:level] == :kana
                    kana.hira_to_kata
                end
            end
            if opts[:level] == :romaji
                line.zen_to_han
            else
                line
            end
        end
        return lines.join
    end

    private

    # read info only when required
    UNIHAN_INFO = {}
    def self.read_unihan
        File.open('./unihan/Unihan_Info','r') do |io|
            io.each_line do |line|
                line.chomp!
                line.strip!
                data = line.split("\t")
                next if line.empty?
                UNIHAN_INFO[data[0].to_i] = data[1]
            end
        end
    end


    # Converts kana to romaji (mostly ascii).
    #   U+3000 -- U+303F is Japanese punctuation
    #   U+3040 -- U+309F is hiragana, U+30A0 -- U+30FF is the katakana block
    #   U+31C0 -- U+9FFF is are CJK blocks (Chinese characters, kanji)
    def self.kana_to_ascii(str, long_vowels = :double, system = :hepburn)
        str = str.normalize_zen_han.kata_to_hira
        # replace now unused kana bigram
        str.gsub!('くゎ','kwa')
        # kana -> ascii
        str.gsub!(/([^\u30fc]+)/) do |text|
            text.gsub(/([\u3001-\u30ff]+)/) do |kana|
                kana.romaji
            end
        end
        # replace long vowels: "a─"  --> "aa" / "ā"
        str.gsub!(/([aiueo])\u30fc/) do
            LONG_VOWELS[long_vowels][$1]
        end
        # replace full-width punctuation
        str.gsub!(/([\u3000-\u303f]|[\u30fb])/) do |marker|
            PUNCTUATION[marker] || marker
        end
        str.tr!('─','-')
        return str
    end

    # Load tagger dynamically when needed.
    def self.get_tagger(dic)
        dicdir = DICFILE[dic]           
        TAGGERS[dic] ||= MeCab::Tagger.new ("--dicdir=#{dicdir}")
        return TAGGERS[dic]
    end

    # Morpheme matches an entry in MERGERS iff all features specified in that
    # entry are present in the morpheme.
    def self.match_merge?(f,m)
        m.keys.inject(true) do |s,k| s && 
            (k==:add || k==:type || 
              (
                (!m[0] || m[0]==f[0]) &&
                (!m[1] || m[1]==f[1]) &&
                (!m[2] || m[2]==f[2]) &&
                (!m[3] || m[3]==f[3]) &&
                (!m[4] || !m[4].any?{|x|!f[4].include?(x)})
              )
            )
        end
    end

    # Decides whether word should be merged with the previous/following word.
    # Table lookup in MERGERS
    def self.mergable?(f, g, mergers)
        val = mergers.find do |m|
            if m.class == Array
                match_merge?(f,m[0]) && match_merge?(g,m[1])
            elsif m[:type] == :prefix 
                match_merge?(f,m)
            else
                match_merge?(g,m)
            end
        end
        if val
            if val.class == Array
                return true, val[0][:add] || ''
            else
                return true, val[:add] || ''
            end
        else
            return false
        end
    end

    # Every dictionary provides a slightly different format.
    # Takes a dictionary line, parses it and returns either nil (invalid/EOS), or
    # [SURFACE_FORM, PHONETIC_SPELLING, KANA_SPELLING, NORMALIZED_SPELLING, [TAGS]]
    def self.parse_dic(str,dic)
        case dic
        when :ipadic
            x = str.split("\t")
            if x[1]
                y = x[1].split(',')
                y.map!{|k| k=='*' ? nil : k}
                z = y.slice!(0..5)
                z.delete(nil)
                y[4] = z
                y[0], y[1], y[2], y[3] = x[0], y[2], y[1], y[0]
                y.slice(0..4)
            end
        when :unidic
            x = str.split("\t")
            if x[0] != "EOS"
                y1 = x[4].to_s.split('-')
                y2 = x[5].to_s.split('-')
                y3 = x[6].to_s.split('-')
                x.delete('')
                x[4] = y1.concat(y2).concat(y3)
                x[0], x[1], x[2], x[3] = x[0], x[1], x[1], x[3]
                x.slice(0..4)
            end
        when :juman
            x = str.split("\t")
            if x[1]
                y = x[1].split(',')
                y.map!{|k| k=='*' ? nil : k}
                z = y.slice!(0..3)
                z.concat(y[2].split(' ')) if y[2]
                z.delete(nil)
                y[4] = z
                y[0], y[1], y[2], y[3] = x[0], y[1], y[1], y[0]
                y.slice(0..4)
            end
        end
    end

    def self.parse_mecab(str,dic)
        tagger = get_tagger(dic)
        surf_idx = 0
        phon_idx = 1
        kana_idx = 2
        norm_idx = 3
        tags_idx = 4
        morphemes = tagger.parse(str).split("\n").map do |line|
            next unless f = parse_dic(line,dic) # ignore EOS (end-of-line)
            add_tag = false
            (1..3).each do |i|
                if f[i].nil? || f[i].empty?
                    add_tag = true
                    f[i] = f[0]
                end
            end
            f[4] << '読仮名なし' if add_tag
            f
        end.compact
        return morphemes
    end

    # Runs the morphological parser to split the Japanese text into morphemes
    # and joins some of them together to produce something more pleasing to the
    # eye.
    def self.kanji_to_kana(str, mode, dic)
        merger = case dic
        when :unidic
            MERGERS_UNIDIC
        when :ipadic
            MERGERS_IPADIC
        when :juman
            MERGERS_JUMAN
        end

        n = case mode
        when :orthographic
            2
        when :phonetic
            1
        end

        # morphological parse
        str.tr!('-','─')
        morphemes = parse_mecab(str,dic)

        # merge morphemes
        kana = []
        morphemes.each do |feature|
            if kana.last && m = mergable?(kana.last.last,feature,merger)
                feature[n] = m[1] + feature[n]
                kana.last << feature
            else
                kana << [feature]
            end
        end

        # convert to kana
        kana = kana.map{|k|k.map{|x|x[n]}.join}.join(' ')
        if mode == :phonetic
            kana.gsub!('ヲ','オ') 
        end

        return kana
    end
end

if caller.empty?
    if (0..6).include?(ARGV.length) && !['-h', '--help'].include?(ARGV[0])
        mode = (ARGV.shift || 'phonetic').downcase.to_sym
        dic = (ARGV.shift || 'unidic').downcase.to_sym
        level = (ARGV.shift || 'romaji').downcase.to_sym
        vowels = (ARGV.shift || 'double').downcase.to_sym
        system = (ARGV.shift || 'hepburn').downcase.to_sym
        pure_ascii = (ARGV.shift || '').downcase.to_s == 'ascii'
        if ![:orthographic,:phonetic].include?(mode)
            $stderr.puts "invalid mode: #{mode}"
        elsif ![:juman,:ipadic,:unidic].include?(dic)
            $stderr.puts "invalid dictionary: #{dic}"
        elsif ![:romaji,:kana].include?(level)
            $stderr.puts "invalid level: #{level}"
        elsif ![:double,:macron].include?(vowels)
            $stderr.puts "invalid mode for long vowels: #{level}"
        elsif ![:kunrei,:hepburn].include?(system)
            $stderr.puts "invalid system: #{system}"
        else
            if mode == :orthographic && dic == :unidic
                $stderr.puts "mode #{mode} not supported by dictionary #{dic}"
            elsif mode == :phonetic && dic == :juman
                $stderr.puts "mode #{mode} not supported by dictionary #{dic}"
            elsif vowels == :macron && dic == :juman
                $stderr.puts "vowel mode #{vowels} not supported by dictionary #{dic}"
            else
                if vowels == :macron && mode == :orthographic
                    $stderr.puts "warning: mode #{mode} makes little sense with vowel mode #{vowels}"
                end
                text = $stdin.read.encode(Encoding::UTF_8)
                if pure_ascii
                    $stdout.puts Japanese.to_ascii(text,
                                                   :mode => mode,
                                                   :dic => dic,
                                                   :level => level,
                                                   :vowels => vowels,
                                                   :system => system)
                else
                    $stdout.puts Japanese.to_phonetic(text,
                                                      :mode => mode,
                                                      :dic => dic,
                                                      :level => level,
                                                      :vowels => vowels,
                                                      :system => system)
                end
            end
        end
    else
        puts "usage: ruby #{$0} [Phonetic|orthographic] [Unidic|juman|ipadic] [Romaji|kana] [Double|macron] [Hepburn|kunrei] [ascii]"
        puts " - reads Japanese text from STDIN"
        puts " - outputs Ascii text to STDOUT"
    end
end
